Part 2: Integrating the RTCC Auth Client into a Rails app
================================================================

In Part 1 of this series, we built a little web site in Rails that had
a login page and a single index page.  To view the index page, a user
needs to be logged in.

In Part 2 of this series, we will add the RTCC security credentials
into the web site.  We will link the RTCC Javascript into the page,
and we will use Javascript to create video calls between different
users logged into the web site.

This tutorial is broadly applicable to the development of any Rails
application using RTCC.  The information in here applies whether you
are coming from Part 1 of our Tutorial Series, or are developing your
own Rails site.


Get your Credentials
----------------

If you have not already, you must request an API KEY.  In response to
this request, you will receive access to the RTCC management portal
where you can access the certificates and keys your web site will use
to enable video chat.


Include the Ruby Authentication Client, Prepare the Certificates
----------------

Our Rails server will incorporate the Ruby authentication client from
https://github.com/sightcall/Authentication-Client/tree/master/Ruby.  Copy the file
```lib/rtcc_auth.rb``` into the ```lib/``` directory of the Rails
project.  Rails automatically loads everything in the lib directory
when it starts.

You will need to put the certificate files you retrieve from the
provider portal on your Rails server.  It is good practice to not
check certificates into a repository, so you may want to put them
somewhere outside of the Rails project.

Following the instructions in
[Ruby](https://github.com/sightcall/Authentication-Client/tree/master/Ruby)
collection, we see that we need to unpack the ```client.p12``` file
into its two components.

- ```privateKey.pem```
- ```publicCert.pem```


Follow the instructions in the Server-SDKs Ruby README file and unpack
the certificates.



Add the Keys and Certs to the Rails Environment
----------------

Open up the file config/environment.rb and add the global variables
describing your configuration.  These lines should go right before the
```Application.initialize!``` call.

```ruby
# config/environment.rb

# Path to the RTCC CA Cert
RTCC_CACERT = "/Path/To/Your/Cert/authCA.crt"

# Paths to the extracted key and cert from the client.p12 file
RTCC_CLIENTCERT = "/Path/To/Your/Cert/publicCert.pem"
RTCC_CLIENTCERT_KEY = "/Path/To/Your/Cert/privateKey.pem"

# Password
RTCC_CERTPASSWORD = "abcdefgh"

# RTCC Authentication endpoint, Client ID and Secret
RTCC_AUTH_URL = "https://auth.rtccloud.net/auth/"
RTCC_CLIENT_ID = "7a7a7a7a7a8b8b8b8b8b9c9c9c9c9c"
RTCC_CLIENT_SECRET = "19ab19ab19ab19ab28cd28cd28cd28"

# RTCC App ID
RTCC_APP_ID = "ab01cd34ef56"
```


Extend the User Model
----------------

Our User model defines the type of information associated with each
user in the system.  We will now extend the User model to provide
information that will be used to authenticate a user to the RTCC
Cloud.  Add the following three methods to User class by editing
app/models/user.rb.



```ruby
# app/models/user.rb

  def rtcc_uid
    "#{name}-uid"
  end

  def rtcc_profile
    "premium"
  end

  def rtcc_domain
    "yourdomain.com"
  end
```

The purpose of each of these fields is explained in a little more
detail on https://github.com/sightcall/Authentication-Client, if you would like to
know more.  The rtcc_uid method returns the User Identifier that will
be exchanged for a token.  In our example system here, that will be the
user's name followed by "-uid".  The UID should be unique in the
system because it is the way that RTCC will provide accounting
information about each user and their calls.  The UID can be something
else, if that's more appropriate, like a user's email, or an opaque
UDID generated by your system.  In this tutorial, we are appending the
"-uid" suffix so that the roles of names and UIDs is clear.  Whatever
mapping you choose, you can define it in this method.

The rtcc_profile maps a user to their capabilities on the RTCC network.  In our
example here, every user will have "premium" access.  Your RTCC
account may have different profile levels.  If it does, this method is
where you can encapsulate the logic that maps your users to RTCC
profiles.

Lastly, the rtcc_domain is an identifier you were provided when you
received your credentials.  (If you are a multi-tenant provider,
contact your support representative for more information on how
to use this field.)




Create a RTCC Controller
----------------

Next, we will create a controller whose job it will be to use the
RTCC Authentication client to request a token on behalf of an authenticated
user.  This controller will implement a single method called
'callback' that returns an access token.  It will be called using Ajax
from a web page using RTCC for WebRTC.

Instead of using a Rails generator, we will contruct this simple
controller by hand.  First, add the following route to the routes
file.

```ruby
# config/routes.rb
post "rtcc/callback"
```

The reason we chose to map this method with a POST is that Rails
includes CSRF protection for POST methods, but not GET methods.  The
test for a signed-in user should be enough to prevent handing out
tokens to the wrong place, but requiring the request to come from a
page that we rendered adds an extra layer of security.

Now implement the controller and method.  Upon initialization (when
the server starts), the controller will instantiate a RTCC
authentication client with the certificates and API KEY we installed
earlier.  Remember that all of these values were set globally in the
config/environment.rb file.

The callback method becomes very simple, indeed.  It checks if there
is a signed-in user.  If there is, it uses the client to request a
token using the uid, domain and profile of the current user.  Voila!
A token is granted.


```ruby
# app/controllers/rtcc_controller.rb
require 'rtcc_auth'

class RtccController < ApplicationController

  def initialize
    @client = RTCCAuth.new(RTCC_AUTH_URL, RTCC_CACERT, RTCC_CLIENTCERT,
                            RTCC_CLIENTCERT_KEY, RTCC_CERTPASSWORD, RTCC_CLIENT_ID, RTCC_CLIENT_SECRET)
    super
  end

  def callback
    if user_signed_in?
      obj = @client.auth(current_user.rtcc_uid,
                         current_user.rtcc_domain,
                         current_user.rtcc_profile)
    else
      obj = { "error" => 500, "error_description" => "unauthenticated user" }
    end

    logger.debug "RTCC#callback #{obj}"

    render :json => obj
  end
end
```


## Test what we have done so far

At this point, our web site should be able to grant a RTCC token to a
logged-in user.  To test our progress at this point, we will take a
little detour and modify our index page to get a token for the current
user by using ajax.

Add a script section to the `index.html.erb` view.  When the page loads, this bit
of code will use Ajax to perform a POST request to the `rtcc/callback`
method.  If all has gone well you will see a JSON object in the page
showing the token retrieved.

```html
# app/views/call/index.html
<script>
$.ajax({
    type: "POST",
    url: "/rtcc/callback",
    cache: false,
    dataType: "JSON"
}).success(function(data) {
   $("body").append("<b>" + JSON.stringify(data) + "</b>");
}).error(function(e) {
   $("body").append("<b>Error:" + e.statusText + "</b>");
});
</script>

```

The JSON token result will look something like this.

```
{"token":"47d00e8bb977dbdea63003009ef2805a9d6eb03c"}
```

If you are happy that the RTCC authentication procedure is working
and that you received a token, you should remove the script code from the
index page.  We will not need it on our next steps.


<hr>

[ Back to [Part 1](HOWTO-part1.md) | Continue to [Part 3](HOWTO-part3.md) ]
